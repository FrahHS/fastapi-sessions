{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FastAPI-Sessions \u00b6 Documentation: https://jordanisaacs.github.io/fastapi-sessions/ Source Code: https://github.com/jordanisaacs/fastapi-sessions/ PyPI: https://pypi.org/project/fastapi-session/ Quickly add session authentication to your FastAPI project. FastAPI Sessions is designed to be user friendly and customizable. Features \u00b6 Dependency injection to protect routes Compatible with FastAPI's auto generated docs Pydantic models for verifying session data Abstract session backend so you can build one that fits your needs Abstract frontends to choose how you extract the session ids (cookies, header, etc.) Create verifiers based on the session data Mix and match frontends and backends Currently Included Backends/Frontends: Backends In memory dictionary Frontends Signed cookies Upcoming: Documentation and user guides More backends and frontends Installation \u00b6 pip install fastapi - sessions Getting Started \u00b6 Check out the guide to using fastapi-sessions: https://jordanisaacs.github.io/fastapi-sessions/guide/getting_started/","title":"About"},{"location":"#fastapi-sessions","text":"Documentation: https://jordanisaacs.github.io/fastapi-sessions/ Source Code: https://github.com/jordanisaacs/fastapi-sessions/ PyPI: https://pypi.org/project/fastapi-session/ Quickly add session authentication to your FastAPI project. FastAPI Sessions is designed to be user friendly and customizable.","title":"FastAPI-Sessions"},{"location":"#features","text":"Dependency injection to protect routes Compatible with FastAPI's auto generated docs Pydantic models for verifying session data Abstract session backend so you can build one that fits your needs Abstract frontends to choose how you extract the session ids (cookies, header, etc.) Create verifiers based on the session data Mix and match frontends and backends Currently Included Backends/Frontends: Backends In memory dictionary Frontends Signed cookies Upcoming: Documentation and user guides More backends and frontends","title":"Features"},{"location":"#installation","text":"pip install fastapi - sessions","title":"Installation"},{"location":"#getting-started","text":"Check out the guide to using fastapi-sessions: https://jordanisaacs.github.io/fastapi-sessions/guide/getting_started/","title":"Getting Started"},{"location":"sessions/","text":"All About Sessions \u00b6 To do","title":"Sessions"},{"location":"sessions/#all-about-sessions","text":"To do","title":"All About Sessions"},{"location":"guide/backends/","text":"Backends \u00b6 To do","title":"Backends"},{"location":"guide/backends/#backends","text":"To do","title":"Backends"},{"location":"guide/getting_started/","text":"Getting started \u00b6 Install FastAPI Sessions \u00b6 The first step is to make sure you have FastAPI installed, along with Uvicorn for testing your API. If this sounds unfamiliar to you, first check out the FastAPI tutorial Assuming you have your environment ready, lets install the library using pip. pip install fastapi - sessions Basic Usage \u00b6 To get up and running with FastAPI sessions there are three main components you will use. SessionFrontend Abstract Class - This class provides the interface for extracting the session IDs from the request whether it is a cookie, header, etc. SessionBackend Abstract Class - This class provides the interface for CRUD operations of your session data. SessionVerifier Abstract Class - This class is where you verify that the provided session ID is actually valid. Now lets take a quick look at a quick API. More details on configurations and design choices will be covered later. Session Data \u00b6 Its as simple as creating a pydantic model. No catches! from pydantic import BaseModel class SessionData ( BaseModel ): username : str Session Frontend \u00b6 We will use the provided SessionCookie frontend. The cookie's value is the signed UUID that is used as a key to the session data on the backend. Take notice of the identifier parameter, it connects the frontend to its corresponding verifier. from fastapi_sessions.frontends.implementations import SessionCookie , CookieParameters cookie_params = CookieParameters () # Uses UUID cookie = SessionCookie ( cookie_name = \"cookie\" , identifier = \"general_verifier\" , auto_error = True , secret_key = \"DONOTUSE\" , cookie_params = cookie_params , ) Session Backend \u00b6 We will use the simple InMemoryBackend[ID, Data]() right now. It stores session data in the server's memory. As SessionCookie utilizes UUID that is our ID type. from uuid import UUID from fastapi_sessions.backends.implementations import InMemoryBackend backend = InMemoryBackend [ UUID , SessionData ]() Session Verifier \u00b6 With the data, frontend, and backend all set up we now need to write our verifier. We will keep it simple and just have it verify that the session exists in the backend. It is a little unseemly as it utilizes Python's abstract classes. Notice we inerit from SessionVerifier which does all the heavy lifting of reading from the backend and obtaining the session from the frontend. The identifier must match the corresponding frontend identifier . from fastapi_sessions.session_verifier import SessionVerifier from fastapi import HTTPException class BasicVerifier ( SessionVerifier [ UUID , SessionData ]): def __init__ ( self , * , identifier : str , auto_error : bool , backend : InMemoryBackend [ UUID , SessionData ], auth_http_exception : HTTPException , ): self . _identifier = identifier self . _auto_error = auto_error self . _backend = backend self . _auth_http_exception = auth_http_exception @property def identifier ( self ): return self . _identifier @property def backend ( self ): return self . _backend @property def auto_error ( self ): return self . _auto_error @property def auth_http_exception ( self ): return self . _auth_http_exception def verify_session ( self , model : SessionData ) -> bool : \"\"\"If the session exists, it is valid\"\"\" return True verifier = BasicVerifier ( identifier = \"general_verifier\" , auto_error = True , backend = backend , auth_http_exception = HTTPException ( status_code = 403 , detail = \"invalid session\" ), ) Bringing it together \u00b6 Now we utilize FastAPI's dependency injection system to protect your routes! Furthermore FastAPI Sessions is compatible with the OpenAPI specs so they will show up in your docs as authenticated routes. Create Session Route \u00b6 Lets start with a simple session creation endpoint. This is not a protected. from uuid import uuid4 from fastapi import FastAPI , Response app = FastAPI () @app . post ( \"/create_session/ {name} \" ) async def create_session ( name : str , response : Response ): session = uuid4 () data = SessionData ( username = name ) await backend . create ( session , data ) cookie . attach_to_response ( response , session ) return f \"created session for { name } \" Now that our user can create a session, lets verify who they are. Notice how we depend on both the cookie and the verifier. The frontend must always be before the verifier as FastAPI Sessions relies on some hackery . It is to enable frontends and backends to be mixed and matched while still taking advantage of dependency injection and autodocs. The cookie extracts the session id and then the verifier checks the validity of the session. from fastapi import Depends @app . get ( \"/whoami\" , dependencies = [ Depends ( cookie )]) async def whoami ( session_data : SessionData = Depends ( verifier )): return session_data To end a session (e.g. logout), just delete it from the backend. As we now require the session_id we move it to be a dependency that returns a value. Not all frontends have the option, but with cookies we can delete it in the response which we do. @app . post ( \"/delete_session\" ) async def del_session ( response : Response , session_id : UUID = Depends ( cookie )): await backend . delete ( session_id ) cookie . delete_from_response ( response ) return \"deleted session\" Putting it all together \u00b6 Now lets put it all back together to see our session based authentication app. Warning While FastAPI-Sessions makes creating session based authentication easy, there are security implications. Please read through all the docs, especially Sessions (forthcoming), and do your own research if you have not worked with cookies and sessions for authentication before. from pydantic import BaseModel from fastapi import HTTPException , FastAPI , Response , Depends from uuid import UUID , uuid4 import sys sys . path . append ( \"..\" ) from fastapi_sessions.backends.implementations import InMemoryBackend from fastapi_sessions.session_verifier import SessionVerifier from fastapi_sessions.frontends.implementations import SessionCookie , CookieParameters class SessionData ( BaseModel ): username : str cookie_params = CookieParameters () # Uses UUID cookie = SessionCookie ( cookie_name = \"cookie\" , identifier = \"general_verifier\" , auto_error = True , secret_key = \"DONOTUSE\" , cookie_params = cookie_params , ) backend = InMemoryBackend [ UUID , SessionData ]() class BasicVerifier ( SessionVerifier [ UUID , SessionData ]): def __init__ ( self , * , identifier : str , auto_error : bool , backend : InMemoryBackend [ UUID , SessionData ], auth_http_exception : HTTPException , ): self . _identifier = identifier self . _auto_error = auto_error self . _backend = backend self . _auth_http_exception = auth_http_exception @property def identifier ( self ): return self . _identifier @property def backend ( self ): return self . _backend @property def auto_error ( self ): return self . _auto_error @property def auth_http_exception ( self ): return self . _auth_http_exception def verify_session ( self , model : SessionData ) -> bool : \"\"\"If the session exists, it is valid\"\"\" return True verifier = BasicVerifier ( identifier = \"general_verifier\" , auto_error = True , backend = backend , auth_http_exception = HTTPException ( status_code = 403 , detail = \"invalid session\" ), ) app = FastAPI () @app . post ( \"/create_session/ {name} \" ) async def create_session ( name : str , response : Response ): session = uuid4 () data = SessionData ( username = name ) await backend . create ( session , data ) cookie . attach_to_response ( response , session ) return f \"created session for { name } \" @app . get ( \"/whoami\" , dependencies = [ Depends ( cookie )]) async def whoami ( session_data : SessionData = Depends ( verifier )): return session_data @app . post ( \"/delete_session\" ) async def del_session ( response : Response , session_id : UUID = Depends ( cookie )): await backend . delete ( session_id ) cookie . delete_from_response ( response ) return \"deleted session\"","title":"Getting Started"},{"location":"guide/getting_started/#getting-started","text":"","title":"Getting started"},{"location":"guide/getting_started/#install-fastapi-sessions","text":"The first step is to make sure you have FastAPI installed, along with Uvicorn for testing your API. If this sounds unfamiliar to you, first check out the FastAPI tutorial Assuming you have your environment ready, lets install the library using pip. pip install fastapi - sessions","title":"Install FastAPI Sessions"},{"location":"guide/getting_started/#basic-usage","text":"To get up and running with FastAPI sessions there are three main components you will use. SessionFrontend Abstract Class - This class provides the interface for extracting the session IDs from the request whether it is a cookie, header, etc. SessionBackend Abstract Class - This class provides the interface for CRUD operations of your session data. SessionVerifier Abstract Class - This class is where you verify that the provided session ID is actually valid. Now lets take a quick look at a quick API. More details on configurations and design choices will be covered later.","title":"Basic Usage"},{"location":"guide/getting_started/#session-data","text":"Its as simple as creating a pydantic model. No catches! from pydantic import BaseModel class SessionData ( BaseModel ): username : str","title":"Session Data"},{"location":"guide/getting_started/#session-frontend","text":"We will use the provided SessionCookie frontend. The cookie's value is the signed UUID that is used as a key to the session data on the backend. Take notice of the identifier parameter, it connects the frontend to its corresponding verifier. from fastapi_sessions.frontends.implementations import SessionCookie , CookieParameters cookie_params = CookieParameters () # Uses UUID cookie = SessionCookie ( cookie_name = \"cookie\" , identifier = \"general_verifier\" , auto_error = True , secret_key = \"DONOTUSE\" , cookie_params = cookie_params , )","title":"Session Frontend"},{"location":"guide/getting_started/#session-backend","text":"We will use the simple InMemoryBackend[ID, Data]() right now. It stores session data in the server's memory. As SessionCookie utilizes UUID that is our ID type. from uuid import UUID from fastapi_sessions.backends.implementations import InMemoryBackend backend = InMemoryBackend [ UUID , SessionData ]()","title":"Session Backend"},{"location":"guide/getting_started/#session-verifier","text":"With the data, frontend, and backend all set up we now need to write our verifier. We will keep it simple and just have it verify that the session exists in the backend. It is a little unseemly as it utilizes Python's abstract classes. Notice we inerit from SessionVerifier which does all the heavy lifting of reading from the backend and obtaining the session from the frontend. The identifier must match the corresponding frontend identifier . from fastapi_sessions.session_verifier import SessionVerifier from fastapi import HTTPException class BasicVerifier ( SessionVerifier [ UUID , SessionData ]): def __init__ ( self , * , identifier : str , auto_error : bool , backend : InMemoryBackend [ UUID , SessionData ], auth_http_exception : HTTPException , ): self . _identifier = identifier self . _auto_error = auto_error self . _backend = backend self . _auth_http_exception = auth_http_exception @property def identifier ( self ): return self . _identifier @property def backend ( self ): return self . _backend @property def auto_error ( self ): return self . _auto_error @property def auth_http_exception ( self ): return self . _auth_http_exception def verify_session ( self , model : SessionData ) -> bool : \"\"\"If the session exists, it is valid\"\"\" return True verifier = BasicVerifier ( identifier = \"general_verifier\" , auto_error = True , backend = backend , auth_http_exception = HTTPException ( status_code = 403 , detail = \"invalid session\" ), )","title":"Session Verifier"},{"location":"guide/getting_started/#bringing-it-together","text":"Now we utilize FastAPI's dependency injection system to protect your routes! Furthermore FastAPI Sessions is compatible with the OpenAPI specs so they will show up in your docs as authenticated routes.","title":"Bringing it together"},{"location":"guide/getting_started/#create-session-route","text":"Lets start with a simple session creation endpoint. This is not a protected. from uuid import uuid4 from fastapi import FastAPI , Response app = FastAPI () @app . post ( \"/create_session/ {name} \" ) async def create_session ( name : str , response : Response ): session = uuid4 () data = SessionData ( username = name ) await backend . create ( session , data ) cookie . attach_to_response ( response , session ) return f \"created session for { name } \" Now that our user can create a session, lets verify who they are. Notice how we depend on both the cookie and the verifier. The frontend must always be before the verifier as FastAPI Sessions relies on some hackery . It is to enable frontends and backends to be mixed and matched while still taking advantage of dependency injection and autodocs. The cookie extracts the session id and then the verifier checks the validity of the session. from fastapi import Depends @app . get ( \"/whoami\" , dependencies = [ Depends ( cookie )]) async def whoami ( session_data : SessionData = Depends ( verifier )): return session_data To end a session (e.g. logout), just delete it from the backend. As we now require the session_id we move it to be a dependency that returns a value. Not all frontends have the option, but with cookies we can delete it in the response which we do. @app . post ( \"/delete_session\" ) async def del_session ( response : Response , session_id : UUID = Depends ( cookie )): await backend . delete ( session_id ) cookie . delete_from_response ( response ) return \"deleted session\"","title":"Create Session Route"},{"location":"guide/getting_started/#putting-it-all-together","text":"Now lets put it all back together to see our session based authentication app. Warning While FastAPI-Sessions makes creating session based authentication easy, there are security implications. Please read through all the docs, especially Sessions (forthcoming), and do your own research if you have not worked with cookies and sessions for authentication before. from pydantic import BaseModel from fastapi import HTTPException , FastAPI , Response , Depends from uuid import UUID , uuid4 import sys sys . path . append ( \"..\" ) from fastapi_sessions.backends.implementations import InMemoryBackend from fastapi_sessions.session_verifier import SessionVerifier from fastapi_sessions.frontends.implementations import SessionCookie , CookieParameters class SessionData ( BaseModel ): username : str cookie_params = CookieParameters () # Uses UUID cookie = SessionCookie ( cookie_name = \"cookie\" , identifier = \"general_verifier\" , auto_error = True , secret_key = \"DONOTUSE\" , cookie_params = cookie_params , ) backend = InMemoryBackend [ UUID , SessionData ]() class BasicVerifier ( SessionVerifier [ UUID , SessionData ]): def __init__ ( self , * , identifier : str , auto_error : bool , backend : InMemoryBackend [ UUID , SessionData ], auth_http_exception : HTTPException , ): self . _identifier = identifier self . _auto_error = auto_error self . _backend = backend self . _auth_http_exception = auth_http_exception @property def identifier ( self ): return self . _identifier @property def backend ( self ): return self . _backend @property def auto_error ( self ): return self . _auto_error @property def auth_http_exception ( self ): return self . _auth_http_exception def verify_session ( self , model : SessionData ) -> bool : \"\"\"If the session exists, it is valid\"\"\" return True verifier = BasicVerifier ( identifier = \"general_verifier\" , auto_error = True , backend = backend , auth_http_exception = HTTPException ( status_code = 403 , detail = \"invalid session\" ), ) app = FastAPI () @app . post ( \"/create_session/ {name} \" ) async def create_session ( name : str , response : Response ): session = uuid4 () data = SessionData ( username = name ) await backend . create ( session , data ) cookie . attach_to_response ( response , session ) return f \"created session for { name } \" @app . get ( \"/whoami\" , dependencies = [ Depends ( cookie )]) async def whoami ( session_data : SessionData = Depends ( verifier )): return session_data @app . post ( \"/delete_session\" ) async def del_session ( response : Response , session_id : UUID = Depends ( cookie )): await backend . delete ( session_id ) cookie . delete_from_response ( response ) return \"deleted session\"","title":"Putting it all together"},{"location":"guide/usage/","text":"Example \u00b6 To document from typing import Tuple , Optional , Any from pydantic import BaseModel from fastapi import FastAPI , Depends , Response , HTTPException from fastapi_sessions import SessionCookie , SessionInfo from fastapi_sessions.backends import InMemoryBackend test_app = FastAPI () class SessionData ( BaseModel ): username : str class BadSessionData ( BaseModel ): fakename : str test_session = SessionCookie ( name = \"session\" , secret_key = \"helloworld\" , backend = InMemoryBackend (), data_model = SessionData , scheme_name = \"Test Cookies\" , auto_error = False ) @test_app . get ( \"/secure\" ) async def secure_thing ( session_data : Optional [ SessionInfo ] = Depends ( test_session )): if session_data is None : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) return { \"message\" : \"You are secure\" , \"user\" : session_data } @test_app . post ( \"/get_session\" ) async def login ( username : str , response : Response , session_info : Optional [ SessionInfo ] = Depends ( test_session )): old_session = None if session_info : old_session = session_info [ 0 ] test_user = SessionData ( username = username ) await test_session . create_session ( test_user , response , old_session ) return { \"message\" : \"You now have a session\" , \"user\" : test_user } @test_app . post ( \"/leave_session\" ) async def logout ( response : Response , session_info : Optional [ SessionInfo ] = Depends ( test_session )): if not session_info : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) await test_session . end_session ( session_info [ 0 ], response ) return { \"message\" : \"You now don't have a session\" , \"user\" : session_info }","title":"Example"},{"location":"guide/usage/#example","text":"To document from typing import Tuple , Optional , Any from pydantic import BaseModel from fastapi import FastAPI , Depends , Response , HTTPException from fastapi_sessions import SessionCookie , SessionInfo from fastapi_sessions.backends import InMemoryBackend test_app = FastAPI () class SessionData ( BaseModel ): username : str class BadSessionData ( BaseModel ): fakename : str test_session = SessionCookie ( name = \"session\" , secret_key = \"helloworld\" , backend = InMemoryBackend (), data_model = SessionData , scheme_name = \"Test Cookies\" , auto_error = False ) @test_app . get ( \"/secure\" ) async def secure_thing ( session_data : Optional [ SessionInfo ] = Depends ( test_session )): if session_data is None : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) return { \"message\" : \"You are secure\" , \"user\" : session_data } @test_app . post ( \"/get_session\" ) async def login ( username : str , response : Response , session_info : Optional [ SessionInfo ] = Depends ( test_session )): old_session = None if session_info : old_session = session_info [ 0 ] test_user = SessionData ( username = username ) await test_session . create_session ( test_user , response , old_session ) return { \"message\" : \"You now have a session\" , \"user\" : test_user } @test_app . post ( \"/leave_session\" ) async def logout ( response : Response , session_info : Optional [ SessionInfo ] = Depends ( test_session )): if not session_info : raise HTTPException ( status_code = 403 , detail = \"Not authenticated\" ) await test_session . end_session ( session_info [ 0 ], response ) return { \"message\" : \"You now don't have a session\" , \"user\" : session_info }","title":"Example"}]}